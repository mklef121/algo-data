
### Common Collections

Rust’s standard library includes a number of very useful data structures called `collections`.
Unlike the built-in `array` and `tuple` types, the data these collections point to is stored on the `heap`, which means the amount of data does not need to be known at compile time and can grow or shrink as the program runs.

#### Storing Lists of Values with `Vectors`

`Vec<T>` also known as a `vector` allow you to store more than one value in a single data structure that puts all the values next to each other in memory. Vectors can only store values of the same type.

strings are implemented as a collection of bytes

#### What Is a String?

Rust has only one string type in the core language, which is the string slice `str` that is usually seen in its borrowed form `&str`. String literals (`let me = "my sample string"`), are stored in the program’s binary and are therefore string slices.

But The `String` type, which is provided by **Rust’s standard library** rather than coded into the core language, is a growable, mutable, owned, UTF-8 encoded string type. 


Many of the same operations available with `Vec<T>` are available with `String` as well because `String` is actually implemented as a wrapper around a **vector of bytes** with some extra guarantees, restrictions, and capabilities. 

```rust
    // This line creates a new, empty string called s, into which we can then load data
    let mut s = String::new();


    let data = "initial contents";
    // this converts a string literal to a `String` type
    let s = data.to_string();

    let mut s = String::from("foo");
    // growing a String pushing to it
    s.push_str("bar");
    // or pushing a single character into it
    s.push('l');

    let s1 = String::from("Hello, ");
    let s2 = String::from("world!");
    let s3 = s1 + &s2; // note s1 has been moved here and can no longer be used

```


A `String` can grow in size and its contents can change, just like the contents of a `Vec<T>`, if you push more data into it.
You can conveniently use the `+` operator or the `format!` macro to concatenate String values.

###### Concatenation with the + Operator 
Often, you’ll want to combine two existing strings. One way to do so is to use the `+` operator

```rust
let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &s2; // note s1 has been moved here and can no longer be used
```

The string `s3` ends up containing `"Hello, world!"`. After the addition, `s1` is no longer valid because the `+` operator uses the `add` method, which takes ownership of the left-hand operand (`s1`) and borrows the right-hand operand (`&s2`).

`fn add(self, s: &str) -> String `

The `s2` has an `&` because the `add` method takes a `&str`, not a `String`. So, you can only add a `&str` to a `String`, not two `String` values. But `&s2` is a `&String`, so why does it work?

Thanks to Rust’s **deref coercion**, `&String` is automatically converted to `&str`—effectively turning `&s2` into `&s2[..]`. That’s why the code compiles.

For combining strings in more complicated ways, we can instead use the format! macro:

```rust
    let s10 = String::from("tic");
    let s11 = String::from("tac");
    let s12 = String::from("toe");

    let s13 = format!("{s1}-{s2}-{s3}");
```
The `format!` macro works like `println!`, but instead of printing the output to the screen, it returns a String with the contents.
The code generated by the `format!` macro uses references so that this call doesn’t take ownership of any of its parameters.


###### Indexing into Strings

> Rust strings don’t support indexing. This is due to how it's represented and stored internally 

A `String` is a wrapper over a `Vec<u8>`

Take a look `let hello = String::from("Hola");` the length of this is `4` which means it takes the vector storing it is 
**4 bytes** long.
But also look at this `let hello = String::from("Здравствуйте");` which is hello in `Cyrillic` alphabet. This is of 
length 24 and not 12 as you might think. So it takes **24 bytes** to represent this in memory. Each Unicode scalar value in that string takes **2 bytes** of storage. Since a bytes will not be enough to endcode a Cyrillic character, accessing `s[0]` will give a wrong result. Due to this and to avoid returning an unexpected value and causing bugs that might not be discovered immediately, Rust does not accept accessing string by index.

ASCII is a 7-bit character encoding that defines 128 characters: the English alphabet, digits, punctuation, and control characters. For example, the letter 'A' is 65 in ASCII.
UTF-8 is a superset of ASCII. The first 128 UTF-8 characters are exactly the same as ASCII.

> Not all UTF-8 is ASCII (because UTF-8 can represent characters way beyond the ASCII range, like emojis or Chinese characters).

###### Bytes and Scalar Values and Grapheme Clusters!

There are actually three relevant ways to look at strings from Rust’s perspective: 
- as bytes, 
- scalar values, and 
- grapheme clusters (the closest thing to what we would call letters).

If we look at the Hindi word **नमस्ते** written in the Devanagari script, it is stored as a `vector` of `u8` values that looks like this:
`[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164, 224, 165, 135]` 
That’s 18 bytes and is how computers ultimately store this data.

If we look at them as Unicode scalar values, which are what Rust’s `char` type is, those bytes look like this:
`['न', 'म', 'स', '्', 'त', 'े']`
There are six `char` values here, but the fourth and sixth are not letters: they’re diacritics that don’t make sense on their own. 

if we look at them as grapheme clusters, we’d get what a person would call the four letters that make up the Hindi word:
`["न", "म", "स्", "ते"]`

> Rust provides different ways of interpreting the raw string data that computers store so that each program can choose the interpretation it needs, no matter what human language the data is in.

Rust doesn’t allow indexing into a `String` to get a character because indexing is expected to be constant time (O(1)), but `String` is UTF-8 encoded. So, to find a specific character, Rust would have to scan from the start to  determine the boundaries of each variable-width character(valid characters) which isn't O(1).

###### Slicing Strings
Indexing into a string is often a bad idea because it’s not clear what the return type of the string-indexing operation should be: a `byte` value, a `character`, a `grapheme cluster`, or a string slice.

Rather than indexing using `[]` with a single number, you can use `[]` with a range to create a string slice containing particular bytes:

```rust
let hello = "Здравствуйте";
/*
 s will be a `&str` that contains the first four bytes of the string
 we mentioned that each of these characters was two bytes, which means `s` will be Зд.
 */
let s = &hello[0..4];

// If we were to try to slice only part of a character’s bytes with something 
//like &hello[0..1], Rust would panic at runtime in the same way as if an invalid index were accessed in a vector:
```
#### Methods for Iterating Over Strings

The best way to operate on pieces of strings is to be explicit about whether you want `characters` or `bytes`.
Calling chars on `“Зд”` separates out and returns two values of type `char`. 
Alternatively, the `bytes` method returns each raw `byte`. E.g

```rust
for c in "Зд".chars() {
    println!("{c}");
}
/*
З
д

*/

for b in "Зд".bytes() {
    println!("{b}");
}

/*
208
151
208
180
*/

```

#### Storing Keys with Associated Values in Hash Maps
The type `HashMap<K, V>` stores a mapping of keys of type `K` to values of type `V` using a hashing function, which determines how it places these keys and values into memory. 

```rust
    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);

    let team_name = String::from("Blue");
    // The get method returns an `Option<&V>`
    // then unwrap_or to set score to zero if scores doesn’t have an entry for the key.
    let score = scores.get(&team_name).copied().unwrap_or(0);

    // iterate over each key–value pair in a hash map
    for (key, value) in &scores {
        println!("{key}: {value}");
    }

    // entry that takes the key you want to check as a parameter. The return value of the entry method is 
    // an enum called Entry that represents a value that might or might not exist.
    scores.entry(String::from("Blue")).or_insert(50);
```

Just like vectors, `hash maps` store their data on the `heap`.


By default, HashMap uses a hashing function called **SipHash** that can provide resistance to denial-of-service (DoS) attacks involving hash tables. This is not the fastest hashing algorithm available, but the trade-off for better security that comes with the drop in performance is worth it.



